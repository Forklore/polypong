// Generated by CoffeeScript 1.6.2
var Game,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.Game = Game = (function(_super) {
  __extends(Game, _super);

  function Game() {
    Game.__super__.constructor.call(this);
    this.loopHandle;
    this.upPressed = false;
    this.downPressed = false;
    this.dir = this.dirIdle;
    this.side = 0;
    this.enemySide = 1;
    this.scores = [0, 0];
    this.dirUpdates = [];
    this.seq = -1;
    this.pos;
    this.timeDiff = null;
    this.ballUpdates = [];
    this.ghostBall;
    this.keyLeft = 37;
    this.keyUp = 38;
    this.keyRight = 39;
    this.keyDown = 40;
    this.keySpace = 32;
    this.startPos = [[10, 80], [760, this.canvasHeight - 80 - this.racketHeight]];
    this.racketColor = '#fff';
  }

  Game.prototype.drawRacket = function(x, y, color) {
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(x, y, this.racketWidth, this.racketHeight);
  };

  Game.prototype.drawBall = function(ball, color) {
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(ball.pos.x, ball.pos.y, this.ballSize, this.ballSize);
  };

  Game.prototype.drawBoard = function() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    this.ctx.fillStyle = 'rgb(200,200,200)';
    this.ctx.fillRect(389, 5, 1, 430);
    this.drawRacket(this.startPos[this.side][0], this.gs[this.side].pos, this.racketColor);
    this.drawRacket(this.startPos[this.enemySide][0], this.gs[this.enemySide].pos, this.racketColor);
    this.drawBall(this.ball, 'rgb(200,200,200)');
    if (this.ghost) {
      return this.drawBall(this.ghost, 'rgb(0,200,0)');
    }
  };

  Game.prototype.gameLoop = function() {
    this.updateState();
    return this.drawBoard();
  };

  Game.prototype.updateState = function() {
    var dt, enemy, me, serverTime, time;

    time = this.time();
    dt = time - this.updateTime;
    if (this.timeDiff != null) {
      serverTime = time - this.timeDiff;
      if (this.ballUpdates.length) {
        this.ball = this.moveBall(this.ballUpdates, serverTime, dt);
      }
    } else {
      this.ball.t = this.updateTime;
      this.ball = this.moveBall([this.ball], time, dt);
    }
    enemy = this.gs[this.enemySide];
    enemy.pos = this.moveRacket(enemy.dir, enemy.updates, enemy.pos, time, this.updateTime);
    me = this.gs[this.side];
    this.pos = this.moveRacket(this.dir, this.dirUpdates, this.pos, time, this.updateTime);
    me.pos = this.pos;
    if (this.dirUpdates.length) {
      this.dir = this.dirUpdates[this.dirUpdates.length - 1].dir;
    }
    return this.updateTime = time;
  };

  Game.prototype.keyboardDown = function(evt) {
    switch (evt.which) {
      case this.keyDown:
        this.downPressed = true;
        this.upPressed = false;
        return this.sendState(this.dirDown);
      case this.keyUp:
        this.upPressed = true;
        this.downPressed = false;
        return this.sendState(this.dirUp);
    }
  };

  Game.prototype.keyboardUp = function(evt) {
    switch (evt.which) {
      case this.keyDown:
        this.downPressed = false;
        if (!this.upPressed) {
          return this.sendState(this.dirIdle);
        }
        break;
      case this.keyUp:
        this.upPressed = false;
        if (!this.downPressed) {
          return this.sendState(this.dirIdle);
        }
    }
  };

  Game.prototype.sendState = function(dir) {
    this.dirUpdates.push({
      dir: dir,
      seq: ++this.seq,
      t: this.time()
    });
    return this.socket.emit('state', {
      dir: dir,
      side: this.side,
      seq: this.seq
    });
  };

  Game.prototype.updateScore = function(scores) {
    var ind, scr, _i, _len, _results;

    _results = [];
    for (ind = _i = 0, _len = scores.length; _i < _len; ind = ++_i) {
      scr = scores[ind];
      _results.push($('#score_' + ind).text(scr));
    }
    return _results;
  };

  Game.prototype.startGame = function() {
    var canvas,
      _this = this;

    canvas = document.getElementById('game_board_canvas');
    this.ctx = canvas.getContext('2d');
    this.updateTime = this.time();
    return this.loopHandle = requestInterval((function() {
      return _this.gameLoop();
    }), this.dt);
  };

  Game.prototype.stopGame = function() {
    $(window).off('keydown');
    $(window).off('keyup');
    return clearRequestInterval(this.loopHandle);
  };

  Game.prototype.seq2index = function(seq) {
    var ind, upd, _i, _len, _ref;

    _ref = this.dirUpdates;
    for (ind = _i = 0, _len = _ref.length; _i < _len; ind = ++_i) {
      upd = _ref[ind];
      if (upd.seq === seq) {
        return ind;
      }
    }
    return -1;
  };

  Game.prototype.time2index = function(keepTime) {
    var b, indFromEnd, _i, _ref;

    indFromEnd = -1;
    _ref = this.ballUpdates;
    for (_i = _ref.length - 1; _i >= 0; _i += -1) {
      b = _ref[_i];
      if (b.t < keepTime) {
        break;
      }
      indFromEnd += 1;
    }
    return this.ballUpdates.length - 2 - indFromEnd;
  };

  Game.prototype.start = function(socket) {
    var _this = this;

    this.socket = socket;
    socket.on('connect', function() {
      return console.log("Socket opened, Master!");
    });
    socket.on('joined', function(data) {
      _this.timeDiff = _this.time() - data.t;
      _this.side = data.side;
      _this.enemySide = _this.side === 0 ? 1 : 0;
      _this.ballUpdates = [];
      _this.dirUpdates = [];
      $(window).on('keydown', function(e) {
        return _this.keyboardDown(e);
      });
      return $(window).on('keyup', function(e) {
        return _this.keyboardUp(e);
      });
    });
    socket.on('move', function(data) {
      var howmany;

      _this.gs = data.gamers;
      howmany = 1 + _this.time2index(_this.time() - _this.timeDiff - 1000);
      _this.ballUpdates.splice(0, howmany);
      _this.ballUpdates.push(data.ball);
      _this.ghost = data.ball;
      if (_this.pos === void 0) {
        _this.pos = _this.gs[_this.side].pos;
      }
      if (_this.gs[_this.side].lastSeq <= _this.lastProcessedSeq) {
        howmany = 1 + _this.seq2index(_this.gs[_this.side].lastSeq);
        return _this.dirUpdates.splice(0, howmany);
      }
    });
    socket.on('score', function(data) {
      return _this.updateScore(data.scores);
    });
    socket.on('busy', function(data) {});
    socket.on('disconnect', function() {
      console.log('Server disconnect');
      return _this.stopGame();
    });
    socket.emit('join');
    return this.startGame();
  };

  return Game;

})(GameCore);

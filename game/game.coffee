# Here is all our socket machimery.
# We have server events:
# - join - user joins the game
# - state - user updates his position
# - disconnect - user disconnects
# And we have client events, generated by server:
# - joined - tell him about success join and which side he will be playing (left or right for now)
# - busy - room is full of players
# - state - update my and others positions
# - quit - some user quitted

GameCore = require './game.core'
cookie = require 'cookie'
timers = require 'timers'
_ = require 'underscore'

class Room extends GameCore
  constructor: (id) ->
    super()
    console.log "room #{id} created"
    @id = id
    @gamers = {}
    @scores = [0, 0]
    @count = 0
    @inDaLoop = false
    initPos = @canvasHeight / 2 - 40
    @gs = [{pos: initPos - @racketHeight, dir: @dirIdle, updates: [], lastSeq: -1},
           {pos: initPos + @racketHeight, dir: @dirIdle, updates: [], lastSeq: -1}]

  addGamer: (sid, gamer) ->
    console.log "gamer #{gamer} added for sid #{sid}"
    @gamers[sid] = gamer 
    @sendJoined sid

  sendJoined: (sid) ->
    @gamers[sid].socket.emit 'joined', @gamers[sid].side if (@gamers[sid])

  sendMove: (sid) ->
    g = @gamers[sid]
    if (g)
      @gs[g.side].updates = g.updates
      g.socket.emit 'move', {gamers: @gs, ball: {pos: @ballPosition, v: @ballV, angle: @angle}}

  sendMoveAll: ->
    for sid of @gamers
      @sendMove sid

  sendScore: (sid) ->
    @gamers[sid].socket.emit 'score', {scores: @scores}

  sendScoreAll: ->
    for sid of @gamers
      @sendScore sid

  updateState: (sid, dir, seq) ->
    @gamers[sid].updates.push {dir: dir, seq: seq, t: @time()} if (@gamers[sid])

  placeBall: (side) ->
    @ballPosition[1] = @gs[side].pos + @racketHeight / 2
    if side == 0
      @ballPosition[0] = @ballResetOffset
      @angle = Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
    else
      @ballPosition[0] = @canvasWidth - @ballResetOffset - @ballSize
      @angle = Math.PI + Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
    @ballV = @initBallV

  moveRackets: (lastTime) ->
    for sid, gamer of @gamers
      gamer.pos = @moveRacket gamer.dir, gamer.updates, gamer.pos, @updateTime, lastTime
      @gs[gamer.side].pos = gamer.pos
      if gamer.updates.length
        lastUpdate = gamer.updates[gamer.updates.length-1]
        gamer.dir = lastUpdate.dir
        @gs[gamer.side].lastSeq = lastUpdate.seq
      gamer.updates = []
      @gs[gamer.side].updates = [] # FIXME seems wrong, clear after updates sent only

  checkScoreUpdate: ->
    if @ballPosition[0] < 0 or @ballPosition[0] > @canvasWidth - @ballSize
      side = -1
      if @ballPosition[0] < 0
        @scores[1] += 1
        side = 0
      if @ballPosition[0] > @canvasWidth - @ballSize
        @scores[0] += 1
        side = 1
      @placeBall side 
      @sendScoreAll()


module.exports = class Game

  constructor: ->
    @rooms = []
    @gamers = {}
    @gamersCount = 0
    @count = 0
    @inDaLoop = false
    @updateTime = null
    @dt = 20
    @dtInSec = @dt/1000
    @lastProcessedSeq = -1

  addGamer: (sid, socket, side) ->
    @gamers[sid] = {socket: socket, updates: [], side: side, room: ""}
    room 
    if _.size(@gamers) % 2 == 1     
      room = new Room(@rooms.length + 1)
      @rooms.push room 
    else 
      room = @rooms[@rooms.length - 1]
    room.addGamer sid, @gamers[sid]
    room.sendJoined sid
    @gamers[sid] = {socket: socket, updates: [], side: side, room: room.id}
    # @sendJoined sid

  # sendJoined: (sid) ->
  #   @gamers[sid].socket.emit 'joined', @gamers[sid].side

  # sendMove: (sid) ->
  #   g = @gamers[sid]
  #   @gs[g.side].updates = g.updates
  #   g.socket.emit 'move', {gamers: @gs, ball: {pos: @ballPosition, v: @ballV, angle: @angle}}

  # sendMoveAll: ->
  #   for sid of @gamers
  #     @sendMove sid

  # sendScore: (sid) ->
  #   @gamers[sid].socket.emit 'score', {scores: @scores}

  # sendScoreAll: ->
  #   for sid of @gamers
  #     @sendScore sid

  # updateState: (sid, dir, seq) ->
  #   @gamers[sid].updates.push {dir: dir, seq: seq, t: @time()}

  # placeBall: (side) ->
  #   @ballPosition[1] = @gs[side].pos + @racketHeight / 2
  #   if side == 0
  #     @ballPosition[0] = @ballResetOffset
  #     @angle = Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
  #   else
  #     @ballPosition[0] = @canvasWidth - @ballResetOffset - @ballSize
  #     @angle = Math.PI + Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
  #   @ballV = @initBallV

  # moveRackets: (lastTime) ->
  #   for sid, gamer of @gamers
  #     gamer.pos = @moveRacket gamer.dir, gamer.updates, gamer.pos, @updateTime, lastTime
  #     @gs[gamer.side].pos = gamer.pos
  #     if gamer.updates.length
  #       lastUpdate = gamer.updates[gamer.updates.length-1]
  #       gamer.dir = lastUpdate.dir
  #       @gs[gamer.side].lastSeq = lastUpdate.seq
  #     gamer.updates = []
  #     @gs[gamer.side].updates = [] # FIXME seems wrong, clear after updates sent only

  # checkScoreUpdate: ->
  #   if @ballPosition[0] < 0 or @ballPosition[0] > @canvasWidth - @ballSize
  #     side = -1
  #     if @ballPosition[0] < 0
  #       @scores[1] += 1
  #       side = 0
  #     if @ballPosition[0] > @canvasWidth - @ballSize
  #       @scores[0] += 1
  #       side = 1
  #     @placeBall side 
  #     @sendScoreAll()
  time: ->
    new Date().getTime()

  startLoop: ->
    return if @inDaLoop
    @gameLoop = timers.setInterval =>
      @gameStep()
    , @dt
    @inDaLoop = true

  endLoop: ->
    return unless @inDaLoop
    timers.clearInterval @gameLoop
    @inDaLoop = false

  gameStep: ->
    lastTime = @updateTime
    @updateTime = @time()
    _.map(@rooms, (room) ->
      room.moveRackets lastTime
      room.moveBall()
      room.checkScoreUpdate()
      room.sendMoveAll()
    )

  oneQuitted: (sidQuit) ->
    delete @gamers[sidQuit]
    for sid, gamer of @gamers
      gamer.socket.emit('quit', sid) if (sidQuit != sid)

  connect: (socket) ->
    sid = cookie.parse(socket.handshake.headers.cookie)['connect.sid']
    console.log "Have a connection: #{sid} (socket id: #{socket.id})"

    socket.on 'join', (data) =>
      if sid of @gamers
        _.map(@rooms, (room) ->
          room.sendJoined sid
          room.sendMove sid
        )
        return
      if @count == 2
        @count = 0
      #   socket.emit 'busy'
      #   return
      console.log "I can has join: #{sid}"
      @addGamer sid, socket, @count
      @count++
      @startLoop()
      # @startLoop() if @count > 0
      # @sendMove sid
      # @sendScore sid

    socket.on 'state', (data) =>
      _.map(@rooms, (room) ->
        room.updateState sid, data.dir, data.seq
      )

    socket.on 'disconnect', =>
      return unless sid of @gamers && @gamers[sid].socket.id == socket.id
      console.log "Disconnecting: #{sid}"
      @oneQuitted sid
      @count--
      @endLoop() if @count == 0

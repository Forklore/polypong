# Here is all our socket machimery.
# We have server events:
# - join - user joins the game
# - state - user updates his position
# - disconnect - user disconnects
# And we have client events, generated by server:
# - joined - tell him about success join and which side he will be playing (left or right for now)
# - busy - room is full of players
# - state - update my and others positions
# - quit - some user quitted

GameCore = require './game.core'
cookie = require 'cookie'
timers = require 'timers'

module.exports = class Player

  constructor: (socket, sid, side, position) ->
    @sid = sid             # socket user id
    @room = 0              # room id - link to room container
    @socket = socket           # socket link
    @updates = []          # updates, that should be sent to socket
    @side = side           # side (left/right)
    @position = position   # position on the desk
    console.log "Initialized player with sid: #{@sid}, side: #{@side}, position: #{@position}"

module.exports = class Room

  constructor: ->
    @id = 0              # room id
    @score = 0           # score in room
    @gamers = {}         # array of room participants
    @count = 0
    @inDaLoop = false    # is game started in the room?
    @state = 0           # 0 - empty
                         # 1 - waiting for second
                         # 2 - game!


module.exports = class Game extends GameCore

  constructor: ->
    super()
    @gamerObjects = {}
    initPos = @canvasHeight / 2 - 40
    @gs = [{pos: initPos - @racketHeight, dir: @dirIdle, updates: [], lastSeq: -1},
           {pos: initPos + @racketHeight, dir: @dirIdle, updates: [], lastSeq: -1}]
    @ballResetOffset = 50
    @scores = [0, 0]
    @count = 0
    @inDaLoop = false

  addGamer: (sid, socket, side) ->
    @gamerObjects[sid] = new Player(socket, sid, side, @gs[side].pos)
    @sendJoined sid

  sendJoined: (sid) ->
    @gamerObjects[sid].socket.emit 'joined', {sid: @gamerObjects[sid].side, t: @time()}

  sendMove: (sid) ->
    go = @gamerObjects[sid]
    @gs[go.side].updates = go.updates
    go.socket.emit 'move', {gamers: @gs, ball: @ball}

  sendMoveAll: ->
    for sid of @gamerObjects
      @sendScore sid

  sendScore: (sid) ->
    @gamerObjects[sid].socket.emit 'score', {scores: @score}

  sendScoreAll: ->
    for sid of @gamerObjects
      @sendScore sid

  updateState: (sid, dir, seq) ->
    @gamerObjects[sid].updates.push {dir: dir, seq: seq, t: @time()} # FIXME not serverTime this should be

  placeBall: (side) ->
    @ball.y = @gs[side].pos + @racketHeight / 2 - @ballSize / 2
    if side == 0
      @ball.x = @ballResetOffset
      @ball.angle = Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
    else
      @ball.x = @canvasWidth - @ballResetOffset - @ballSize
      @ball.angle = Math.PI + Math.asin((@gs[1].pos - @gs[0].pos) / (@canvasWidth - 2 * @xOffset))
    @ball.v = @initBallV

  moveRackets: (currentTime) ->
    for sid, gamer of @gamerObjects
      gamer.pos = @moveRacket gamer.dir, gamer.updates, gamer.pos, currentTime, @updateTime
      @gs[gamer.side].pos = gamer.pos
      if gamer.updates.length
        lastUpdate = gamer.updates[gamer.updates.length-1]
        gamer.dir = lastUpdate.dir
        @gs[gamer.side].lastSeq = lastUpdate.seq
      gamer.updates = []
      @gs[gamer.side].updates = [] # FIXME seems wrong, clear after updates sent only

  checkScoreUpdate: ->
    if @ball.x < 0 or @ball.x > @canvasWidth - @ballSize
      side = -1
      if @ball.x < 0
        @scores[1] += 1
        side = 0
      if @ball.x > @canvasWidth - @ballSize
        @scores[0] += 1
        side = 1
      @placeBall side
      @sendScoreAll()

  startLoop: ->
    return if @inDaLoop
    @gameLoop = timers.setInterval =>
      @gameStep()
    , @dt
    @inDaLoop = true

  endLoop: ->
    return unless @inDaLoop
    timers.clearInterval @gameLoop
    @inDaLoop = false
    @scores = [0, 0]

  gameStep: ->
    time = @time()
    @moveRackets time
    @ball.t = @updateTime
    @ball = @moveBall [@ball], time, (time - @updateTime)
    @ball.t = time
    @checkScoreUpdate()
    @sendMoveAll()
    @updateTime = time

  oneQuitted: (sidQuit) ->
    delete @gamerObjects[sidQuit]
    for sid, gamer of @gamerObjects
      gamer.socket.emit('quit', sid) if (sidQuit != sid)

  connect: (socket) ->
    sid = cookie.parse(socket.handshake.headers.cookie)['connect.sid']
    console.log "Have a connection: #{sid} (socket id: #{socket.id})"

    socket.on 'join', (data) =>
      if sid of @gamerObjects
        @sendJoined sid
        @sendMove sid
        return
      if @count == 2
        socket.emit 'busy'
        return
      console.log "I can has join: #{sid}"
      @addGamer sid, socket, @count
      @count++
      @startLoop() if @count > 0
      @sendMove sid
      @sendScore sid

    socket.on 'state', (data) =>
      @updateState sid, data.dir, data.seq

    socket.on 'disconnect', =>
      return unless sid of @gamerObjects && @gamerObjects[sid].socket.id == socket.id
      console.log "Disconnecting: #{sid}"
      @oneQuitted sid
      @count--
      @endLoop() if @count == 0
